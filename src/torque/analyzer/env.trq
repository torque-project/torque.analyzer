(ns torque.analyzer.env)

(def ^:dynamic *env*
  nil)

(defn ^:private throw-not-an-env [x]
  (throw
    (ex-info
      (str "global env must be a map or atom containing a map, not "
           (type x))
      {:env x})))

(defn ^:private env? [x]
  (and (instance? torque.lang.atom/Atom x)
       (map? @x)))

(defmacro with-env
  [env & body]
  `(let [env# ~env
         env# (cond
                (map? env#) (atom env#)
                (env? env#) env#
                :default    (throw-not-an-env env#))]
     (binding [*env* env#]
       ~@body)))

;; if *env* is not bound, bind it to env
(defmacro ensure
  [env & body]
  `(if *env*
     (do ~@body)
     (with-env ~env
       ~@body)))

(defn deref-env
  []
  (if *env*
    @*env*
    (throw (ex-info "Global env not bound" {}))))
