;; -*- mode: clojure;-*-

(ns torque.analyzer.torque
  (:require
    [torque.analyzer :as a]
    [torque.analyzer.env :as e]
    [torque.analyzer.utils :as u]
    [torque.analyzer.resolver :as r]
    [torque.io :as io]
    [torque.reader :as rdr]))

(def ^:dynamic *resolver*)

(def ^:dynamic *eval*)

(def *protocol-id* (atom 0))

(declare analyze)

;; TODO: don't do incremental ids. we should use timestamps
;; or some other form of id, which doesn't depend on a stored
;; counter
(defn next-protocol-id []
  (swap! *protocol-id* inc))

(defn create-var [sym env]
  (with-meta {:op   :var
              :name sym
              :ns   (:ns env)}
    (meta sym)))

(defn var? [x]
  (= :var (:op x)))

(defn macroexpand-1 [x env]
  x)

(defn ^:private throw-does-not-start-with-ns [ns]
  (throw
    (ex-info (str "Namespace file does not start with ns form: " ns)
      {:ns ns})))

(defn ^:private throw-ns-resource-not-found [ns]
  (throw
    (ex-info (str "Can't find physical resource for name space: " ns)
      {:ns ns})))

(defn load-ns [sym]
  (if-let [lookup (r/resolve-ns *resolver* sym)]
    (with-resource [stream (:file lookup)]
      (binding [*resolver* (r/project-resolver (:project lookup))]
        (let [stream (rdr/io-stream (io/buffered stream 80))
              ns     (analyze (rdr/read stream))]
          (if (= (:op ns) :ns)
            (loop [out []]
              ;; TODO: bind reader environment for syntax quote, etc.
              (let [o (rdr/read stream)]
                (if-not (= o :torque.reader/eof)
                  (let [ast (analyze o)]
                    (recur (conj out ast)))
                  (swap! e/*env* assoc-in
                         [:namespaces sym :forms]
                         out))))
            (throw-does-not-start-with-ns ns)))))
    (throw-ns-resource-not-found sym)))

(defn ensure-loaded [ns env]
  (or (u/resolve-ns ns (e/deref-env))
      (load-ns ns)))

(defn ^:private simplify-deps [form]
  ;; TODO: convert use to require
  )

(defn ^:private deps->map [dependencies]
  (reduce
    (fn [m x]
      (assoc m (first x)
        (reduce
          (fn [m y]
            (if (vector? y)
              (assoc m (first y) (apply hash-map (rest y)))
              (assoc m y {})))
          {}
          (next x))))
    {}
    dependencies))

(defn ^:private resolve-requires [requires env]
  (reduce
    (fn [m dep]
      (let [lib   (first dep)
            opts  (second dep)
            as    (:as opts)
            refer (:refer opts)]
        ;; load namespace recursively
        (ensure-loaded lib env)
        ;; update env an namespace AST
        (cond-> m
          as    (assoc-in [:aliases as] lib)
          refer (identity))))
    {}
    requires))

(defn ^:private resolve-deps [dependencies env]
  (resolve-requires (:require dependencies) env))

(defn ^:private populate-env [name form env]
  (let [dependencies  (-> form deps->map)
        resolved-deps (resolve-deps dependencies env)]
    (swap! e/*env* assoc :ns name)
    (swap! e/*env* assoc-in [:namespaces name]
           (merge {:ns name}
                  resolved-deps))
    dependencies))

(defmulti parse (fn [form env] (first form)))

(defmethod parse :default [form env]
  (a/-parse form env))

(defmethod parse 'ns [form env]
  (let [name (second form)
        args (nnext form)
        doc  (if (string? (first args))
               (first args)
               nil)
        opts (populate-env name
               (if doc
                 (rest args)
                 args)
               env)]
    (merge
      {:op      :ns
       :env     env
       :form    form
       :name    name
       :depends (set (keys (:require opts)))}
      (when doc
        {:doc doc}))))

(defmethod parse 'dispatch* [form env]
  (let [spec     (next form)
        protocol (a/analyze-form (first spec) env)
        method   (second spec)
        args     (mapv (a/analyze-in-env env) (nnext spec))]
    {:op       :dispatch
     :form     form
     :protocol protocol
     :method   method
     :args     (vec args)}))

(defmethod parse 'defprotocol [form env]
  (let [name  (second form)
        decl  (nnext form)
        args  (if (string? (first decl))
                [(first decl) (next decl)]
                [nil decl])
        doc   (first args)
        meths (second args)]
    (swap! e/*env* assoc-in
           [:namespaces (:ns env) :mappings name]
           {:op        :var
            :protocol? true
            :form      form
            :name      name
            :meths     meths
            :id        (next-protocol-id)})
    (a/parse-do
      `(do
         ~@(map (fn [meth id]
                  (let [sym  (first meth)
                        sigs (rest meth)]
                    `(def ~sym
                       (fn* ~sym
                            ~@(map (fn [sig]
                                     (->> `(dispatch* ~name ~id ~@sig)
                                          (list sig)))
                                   sigs)))))
                meths (range))
         nil
         ;; ~name
         )
      env)))

(defn ^:private analyze-extensions [extensions env]
  (loop [protos extensions
         out    []]
    (if-let [sym (first protos)]
      ;; TODO: check impls against protocol
      (let [proto (u/resolve-sym sym env)
            meths (take-while (complement symbol?) (next protos))
            ops   (->> meths
                       (mapv
                         (fn [meth]
                           (assoc (a/analyze-fn-method (next meth) env)
                             :name (first meth))))
                       (group-by :name)
                       (vector :methods)
                       (conj {:op :extension :protocol proto}))]
        (recur (nthrest protos (inc (count ops)))
               (conj out ops)))
      out)))

(defmethod parse 'deftype [form env]
  (let [name   (second form)
        spec   (nnext form)
        decl   (if (string? (second spec))
                 [(second spec) (nnext spec)]
                 [nil (next spec)])
        doc    (nth decl 0)
        fields (mapv
                 (fn [field id]
                   {:op       :binding
                    :env      env
                    :form     field
                    :name     field
                    :field-id id
                    :local    :field})
                 (first spec) (range))
        tenv   (assoc-in env [:locals] (zipmap (map :name fields) fields))
        exts   (analyze-extensions (nth decl 1) tenv)]
    (swap! e/*env* assoc-in
           [:namespaces (:ns env) :mappings name]
           {:op         :var
            :type?      true
            :form       form
            :name       name
            :extensions exts})
    (merge
      {:op         :deftype
       :env        env
       :name       name
       :fields     fields
       :extensions exts}
      (when doc
        {:doc doc}))))

(defn analyze [form]
  (binding [a/parse         parse
            a/macroexpand-1 macroexpand-1
            a/create-var    create-var
            a/var?          var?]
    (a/analyze form (e/deref-env))))
