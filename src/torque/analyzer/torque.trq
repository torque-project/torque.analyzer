;; -*- mode: clojure;-*-

(ns torque.analyzer.torque
  (:require
    [torque.analyzer :as a]
    [torque.analyzer.ast :as ast]
    [torque.analyzer.env :as e]
    [torque.analyzer.pass :as pass]
    [torque.analyzer.resolver :as r]
    [torque.analyzer.utils :as u]
    [torque.io :as io]
    [torque.reader :as rdr]))

(def ^:dynamic *resolver*)
(def ^:dynamic *eval*)

(def *protocol-id* (atom -1))

(def specials
  (hash-set
    'ns 'fn* 'if 'let* 'loop* 'recur 'do 'binding*
    'defprotocol 'protocol* 'deftype 'dispatch*
    'quote 'def 'new 'set! '. 'apply*
    'so* 'import* 'invoke*))

(declare analyze)

;; TODO: don't do incremental ids. we should use timestamps
;; or some other form of id, which doesn't depend on a stored
;; counter
(defn next-protocol-id []
  (swap! *protocol-id* inc))

(defn create-var [sym env]
  {:op   :var
   :name sym
   :ns   (:ns env)
   ;;:meta (meta sym)
   })

(defn var? [x]
  (= :var (:op x)))

(defn builtin? [sym]
  (some-> (namespace sym) (= "torque.core.builtin")))

(defn macroexpand-1 [form env]
  (if (and (seq? form))
    (let [sym (first form)]
      (if (not (or (specials sym) (builtin? sym)))
        (when-let [macro (resolve sym)]
          (if (-> macro meta :macro)
            (apply @macro (rest form))
            form))
        form))
    form))

(def ^:private *capture-context*)

(defn ^:private capture-locals [ast]
  (if (ast/is? ast :fn)
    (do
      (swap! *capture-context* conj
             {:captured    (-> ast :env :locals)
              :closed-over (hash-set)})
      ast)
    ast))

(defn ^:private collect-closed-overs [ast]
  (cond
    (ast/is? ast :local)
      (do
        (when (-> @*capture-context* peek :captured (get (:name ast)))
          (swap! *capture-context*
                 (fn [v]
                   (update-in v [(dec (count v)) :closed-over] conj (:name ast)))))
        ast)
    (ast/is? ast :fn)
      (let [captured (peek @*capture-context*)]
        (swap! *capture-context* pop)
        (assoc ast :closing-over (:closed-over captured)))
    :else
      ast))

(defn ^:private analyze-captures [ast]
  (binding [*capture-context* (atom (vector))]
    (pass/transduce ast ast/children capture-locals collect-closed-overs)))

(defn ^:private throw-does-not-start-with-ns [ns]
  (throw
    (ex-info (str "Namespace file does not start with ns form: " ns)
      {:ns ns})))

(defn ^:private throw-ns-resource-not-found [ns]
  (throw
    (ex-info (str "Can't find physical resource for name space: " ns)
      {:ns ns})))

(defn load-ns [sym]
  ;; (println "LOADING: " sym)
  (if-let [lookup (r/resolve-ns *resolver* sym)]
    (with-resource [stream (:file lookup)]
      (binding [*resolver* (r/project-resolver (:project lookup))]
        (let [stream (rdr/io-stream (io/buffered stream 80))
              ns     (analyze (rdr/read stream))]
          (if (= (:op ns) :ns)
            ;; TODO: when not bootstrapping anymore, we would have to
            ;; eval the ns statement, too
            (binding [*ns* (the-ns (:name ns))]
              (loop [out []]
                ;; TODO: bind reader environment for syntax quote, etc.
                (let [o (rdr/read stream)]
                  ;; (print o)
                  (if-not (= o :torque.reader/eof)
                    (let [ast (analyze o)]
                      ;; eval form so we can use it in macros
                      (*eval* ast)
                      (recur (conj out ast)))
                    (swap! e/*env* assoc-in
                           [:namespaces sym :forms]
                           out)))))
            (throw-does-not-start-with-ns ns)))))
    (throw-ns-resource-not-found sym)))

(defn ensure-loaded [ns env]
  (or (u/resolve-ns ns (e/deref-env))
      (load-ns ns)))

(defn ^:private simplify-deps [form]
  ;; TODO: convert use to require
  )

(defn ^:private deps->map [dependencies]
  (reduce
    (fn [m x]
      (assoc m (first x)
        (reduce
          (fn [m y]
            (if (vector? y)
              (assoc m (first y) (apply hash-map (rest y)))
              (assoc m y {})))
          {}
          (next x))))
    {}
    dependencies))

(defn ^:private filter-referal [filter lib]
  (if (= filter :all)
    (:mappings lib)
    (select-keys filter (:mappings lib))))

(defn ^:private refer-ns [ns lib filter]
  (update-in ns [:mappings] merge (filter-referal filter lib)))

(defn ^:private resolve-requires [m requires env]
  (reduce
    (fn [m dep]
      (let [lib     (first dep)
            opts    (second dep)
            as      (:as opts)
            refer   (:refer opts)]
        ;; load namespace recursively
        (ensure-loaded lib env)
        ;; update env an namespace AST
        (cond-> m
          as      (assoc-in [:aliases as] lib)
          refer   (refer-ns
                    (-> (e/deref-env) :namespaces (get lib))
                    refer))))
    m
    requires))

(defn ^:private resolve-inherits [m inherits env]
  (reduce
    (fn [m dep]
      (let [lib (first dep)]
        (ensure-loaded lib env)
        (refer-ns m
          (-> (e/deref-env) :namespaces (get lib))
          :all)))
    m
    inherits))

(defn ^:private resolve-deps [dependencies env]
  (-> (resolve-requires {}  (:require dependencies) env)
      (resolve-inherits (:inherit dependencies) env)))

(defn ^:private populate-env [name form env]
  (let [dependencies  (-> form deps->map)
        resolved-deps (resolve-deps dependencies env)]
    (swap! e/*env* assoc :ns name)
    (swap! e/*env* assoc-in [:namespaces name]
           (merge {:ns name}
                  resolved-deps))
    dependencies))

(defmulti parse (fn [form env] (first form)))

(defmethod parse :default [form env]
  (a/-parse form env))

(defmethod parse 'ns [form env]
  (let [name (second form)
        args (nnext form)
        doc  (if (string? (first args))
               (first args)
               nil)
        opts (populate-env name
               (if doc
                 (rest args)
                 args)
               env)]
    (merge
      {:op      :ns
       :env     env
       :form    form
       :name    name
       :depends (set (keys (:require opts)))}
      (when doc
        {:doc doc}))))

(defmethod parse 'dispatch* [form env]
  (let [spec     (next form)
        protocol (a/analyze-form (first spec) env)
        method   (second spec)
        args     (mapv (a/analyze-in-env env) (nnext spec))]
    {:op       :dispatch
     :form     form
     :protocol protocol
     :method   method
     :args     (vec args)}))

(defmethod parse 'protocol* [form env]
  (let [name  (second form)
        id    (first (nnext form))
        meths (nthrest form 3)]
    {:op    :protocol
     :form  form
     :name  name
     :meths (vec meths)
     :id    id}))

(defmethod parse 'defprotocol [form env]
  (let [name  (second form)
        decl  (nnext form)
        args  (if (string? (first decl))
                [(first decl) (next decl)]
                [nil decl])
        doc   (first args)
        id    (next-protocol-id)
        meths (second args)]
    (a/parse-do
      `(do
         (def ~name (protocol* ~name ~id ~@meths))
         ~@(map (fn [meth id]
                  (let [sym  (first meth)
                        sigs (rest meth)]
                    `(def ~sym
                       (fn* ~sym
                            ~@(map (fn [sig]
                                     (->> `(dispatch* ~name ~id ~@sig)
                                          (list sig)))
                                   sigs)))))
                meths (range))
         nil
         ;; ~name
         )
      env)))

(defn ^:private analyze-extensions [extensions env]
  (loop [protos extensions
         out    []]
    (if-let [sym (first protos)]
      ;; TODO: check impls against protocol
      (let [proto (u/resolve-sym sym env)
            meths (take-while (complement symbol?) (next protos))
            ops   (->> meths
                       (mapv
                         (fn [meth]
                           (assoc (a/analyze-fn-method (next meth) env)
                             :name (first meth))))
                       (group-by :name)
                       (vector :methods)
                       (conj {:op :extension :protocol proto}))]
        (recur (nthrest protos (inc (count meths)))
               (conj out ops)))
      out)))

(defmethod parse 'deftype [form env]
  (let [sym    (second form)
        spec   (nnext form)
        decl   (if (string? (second spec))
                 [(second spec) (nnext spec)]
                 [nil (next spec)])
        doc    (nth decl 0)
        fields (mapv
                 (fn [field id]
                   {:op       :binding
                    :env      env
                    :form     field
                    :name     field
                    :field-id id
                    :mutable  (-> field meta :mutable)
                    :local    :field})
                 (first spec) (range))
        ;; TODO: should do this in 'def
        _ (swap! e/*env* assoc-in
                 [:namespaces (:ns env) :mappings sym]
                 {:op         :var
                  :type?      true
                  :form       form
                  :name       sym})
        tenv   (assoc-in env [:locals] (zipmap (map :name fields) fields))
        exts   (analyze-extensions (nth decl 1) tenv)]
    (merge
      {:op         :deftype
       :env        env
       :name       sym
       :fields     fields
       :extensions exts}
      (when doc
        {:doc doc}))))

(defmethod parse 'def [form env]
  (let [parsed   (a/-parse form env)
        protocol (:init parsed)]
    (when (= (:op protocol) :protocol)
      (swap! e/*env* update-in
             [:namespaces (:ns env) :mappings (:name parsed) :var]
             merge
             (dissoc protocol :op)
             {:protocol? true}))
    parsed))

(defn analyze [form]
  (binding [a/parse         parse
            a/macroexpand-1 macroexpand-1
            a/create-var    create-var
            a/var?          var?]
    (->> (e/deref-env)
         (a/analyze form)
         (analyze-captures))))
