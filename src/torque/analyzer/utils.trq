;; -*- mode: clojure;-*-
;;   Copyright (c) Nicola Mometto, Rich Hickey & contributors.
;;   The use and distribution terms for this software are covered by the
;;   Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)
;;   which can be found in the file epl-v10.html at the root of this distribution.
;;   By using this software in any fashion, you are agreeing to be bound by
;;   the terms of this license.
;;   You must not remove this notice, or any other, from this software.

(ns torque.analyzer.utils
  (:require
    [torque.analyzer.env :as env]))

(declare conj! rseq reduce-kv sort-by)

(defn into!
  [to from]
  (reduce conj! to from))

(defn rseqv
  [v]
  (vec (rseq v)))

(defn ctx
  [env ctx]
  (assoc env :context ctx))

(defn dissoc-env
  [ast]
  (dissoc ast :env))

(defn butlast+last
  [s]
  (loop [butlast (transient [])
         s s]
    (if-let [xs (next s)]
      (recur (conj! butlast (first s)) xs)
      [(seq (persistent! butlast)) (first s)])))

(defn update-vals
  [m f]
  (reduce-kv (fn [m k v] (assoc m k (f v))) {} (or m {})))

(defn update-keys
  [m f]
  (reduce-kv (fn [m k v] (assoc m (f k) v)) {} (or m {})))

(defn update-kv
  [m f]
  (reduce-kv (fn [m k v] (assoc m (f k) (f v))) {} (or m {})))

;; (defmacro compile-if
;;   [exp then & else]
;;   (if (try (eval exp)
;;            (catch Exception _ false))
;;     `(do ~then)
;;     `(do ~@else)))

;; (defn regex?
;;   "Returns true if x is a regex"
;;   [x]
;;   (instance? (compile-if (Class/forName "java.util.regex.Pattern")
;;                java.util.regex.Pattern
;;                System.Text.RegularExpressions.Regex)
;;              x))

(defn boolean?
  [x]
  (or (true? x) (false? x)))

(defn classify
  [form]
  (cond
    (nil? form)     :nil
    (boolean? form) :bool
    (keyword? form) :keyword
    (symbol? form)  :symbol
    (string? form)  :string
    (number? form)  :number
    (type? form)    :type
    (record? form)  :record
    (map? form)     :map
    (vector? form)  :vector
    (set? form)     :set
    (seq? form)     :seq
    ;; (regex? form)   :regex
    ;; (var? form)     :var
    :else           :unknown))

(defn private?
  ([var]   (private? var nil))
  ([var m] (:private (or m (meta var)))))

(defn macro?
  ([var]   (macro? var nil))
  ([var m] (:macro (or m (meta var)))))

(defn constant?
  ([var]   (constant? var nil))
  ([var m] (:const (or m (meta var)))))

(defn dynamic?
  ([var]
   (dynamic? var nil))
  ([var m]
   (:dynamic (or m (meta var)))))

;; workaround needed since Clojure doesn't always propagate :dynamic

(defn protocol-node?
  ([var] (protocol-node? var nil))
  ([var m]
    (boolean (:protocol (or m (meta var))))))

;; conveniently this is true in both clojure and clojurescript

(defn resolve-ns
  [ns-sym env]
  (let [ns (:ns env)]
    (when ns-sym
      (let [namespaces (:namespaces (env/deref-env))]
        (or (get-in namespaces [ns :aliases ns-sym])
            (:ns (get namespaces ns-sym)))))))

(defn resolve-sym
  [sym env]
  (when (symbol? sym)
    (let [ns      (:ns env)
          sym-ns  (when-let [ns (namespace sym)]
                    (symbol ns))
          full-ns (resolve-ns sym-ns env)]
      (when (or (not sym-ns) full-ns)
        (let [name (if sym-ns (-> sym name symbol) sym)]
          (-> (env/deref-env)
              :namespaces
              (get (or full-ns ns))
              :mappings
              (get name)))))))

;; (defn arglist-for-arity
;;   [fn argc]
;;   (let [arglists (->> fn :arglists (sort-by count))
;;         arglist (->> arglists (filter (fn [x] (= argc (count x)))) first)
;;         last-arglist (last arglists)]
;;     (or arglist
;;         (when (and (some #{'&} last-arglist)
;;                    (>= argc (- (count last-arglist) 2)))
;;           last-arglist))))

(defn select-keys'
  [map keyseq]
  (loop [ret (transient {}) keys (seq keyseq)]
    (if keys
      (let [entry (find map (first keys))]
        (recur (if entry
                 (conj! ret entry)
                 ret)
               (next keys)))
      (persistent! ret))))

;; (defn merge'
;;   [m & mms]
;;   (persistent! (reduce conj! (transient (or m {})) mms)))

;; (defn mapv'
;;   [f v]
;;   (let [c (count v)]
;;     (loop [ret (transient []) i 0]
;;       (if (> c i)
;;         (let [val (f (nth v i))]
;;           (if (reduced? val)
;;             (reduced (persistent! (reduce conj! (conj! ret @val) (subvec v (inc i)))))
;;             (recur (conj! ret val) (inc i))))
;;         (persistent! ret)))))

(defn source-info
  [m]
  (when (:line m)
    (select-keys m #{:file :line :column :end-line :end-column :source-span})))

(defn -source-info
  [x env]
  (merge (source-info env)
         (source-info (meta x))
         (when-let [file "NO_SOURCE_FILE"]
           {:file file})))

;; (and (not= *file* "NO_SOURCE_FILE")
;;      *file*)

(defn const-val [x]
  (or (:val x) (:form x)))

;; (def mmerge
;;   "Same as (fn [m1 m2] (merge-with merge m2 m1))"
;;   (fn [x y] (merge-with merge' y) x))
